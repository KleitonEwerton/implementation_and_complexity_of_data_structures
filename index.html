<!DOCTYPE html>
<html lang="pt-BR">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Estrutura de Dados em C++</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Google Fonts - Inter -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #030712;
            /* gray-950 */
            color: #d1d5db;
            /* gray-300 */
        }

        /* Estilo para simular realce de código */
        pre code {
            white-space: pre-wrap;
            /* Quebra de linha para código longo em telas pequenas */
            word-break: break-all;
            /* Força quebra de linha em palavras longas */
        }

        /* Ajustes responsivos para fontes e padding em telas pequenas */
        @media (max-width: 640px) {
            .text-3xl {
                font-size: 2rem;
            }

            .text-2xl {
                font-size: 1.5rem;
            }

            .text-xl {
                font-size: 1.25rem;
            }

            .p-4 {
                padding: 1rem;
            }

            .sm\:p-6 {
                padding: 1rem;
            }

            .lg\:p-8 {
                padding: 1rem;
            }

            .flex-wrap {
                flex-wrap: wrap;
            }

            .gap-3 {
                gap: 0.75rem;
            }
        }
    </style>
</head>

<body class="min-h-screen">

    <header class="bg-gray-800 p-4 shadow-lg sticky top-0 z-10 rounded-b-lg">
        <nav class="max-w-7xl mx-auto flex flex-wrap justify-center sm:justify-start gap-3">
            <button onclick="showExercise('1')"
                class="px-4 py-2 rounded-lg font-medium transition-all duration-300 ease-in-out bg-gray-700 text-gray-200 hover:bg-blue-500 hover:text-white"
                id="btn-exercise-1">Exercício 1</button>
            <button onclick="showExercise('2')"
                class="px-4 py-2 rounded-lg font-medium transition-all duration-300 ease-in-out bg-gray-700 text-gray-200 hover:bg-blue-500 hover:text-white"
                id="btn-exercise-2">Exercício 2</button>
            <button onclick="showExercise('3')"
                class="px-4 py-2 rounded-lg font-medium transition-all duration-300 ease-in-out bg-gray-700 text-gray-200 hover:bg-blue-500 hover:text-white"
                id="btn-exercise-3">Exercício 3</button>
            <button onclick="showExercise('4')"
                class="px-4 py-2 rounded-lg font-medium transition-all duration-300 ease-in-out bg-gray-700 text-gray-200 hover:bg-blue-500 hover:text-white"
                id="btn-exercise-4">Exercício 4</button>
            <button onclick="showExercise('5')"
                class="px-4 py-2 rounded-lg font-medium transition-all duration-300 ease-in-out bg-gray-700 text-gray-200 hover:bg-blue-500 hover:text-white"
                id="btn-exercise-5">Exercício 5</button>
        </nav>
    </header>

    <main class="max-w-7xl mx-auto py-8" id="content-area">
        <!-- O conteúdo dos exercícios será carregado aqui pelo JavaScript -->
    </main>

    <footer class="bg-gray-800 p-4 text-center text-gray-400 mt-12 rounded-t-lg">
        <p>&copy; 2025 Soluções de Estrutura de Dados - Kleiton Ewerton</p>
    </footer>

    <script>
        // Função auxiliar para criar um card de conteúdo
        function createContentCard(title, contentHtml, className = '') {
            return `
                <div class="bg-gray-800 p-6 rounded-lg shadow-lg mb-6 ${className}">
                    <h3 class="text-xl font-semibold text-white mb-4 border-b border-gray-700 pb-2">${title}</h3>
                    <div class="text-gray-300">
                        ${contentHtml}
                    </div>
                </div>
            `;
        }

        // Função auxiliar para criar um bloco de código
        function createCodeBlock(code, language = 'cpp') {
            return `
                <pre class="bg-gray-900 p-4 rounded-md overflow-x-auto text-sm">
                    <code class="language-${language} text-green-300 font-mono">
                        ${code}
                    </code>
                </pre>
            `;
        }

        // Conteúdo para o Exercício 1
        const exercise1Content = `
            <h2 class="text-3xl sm:text-4xl font-bold text-white mb-6">Exercício 1: Implementação e Complexidade de Estruturas de Dados</h2>
            ${createContentCard(
            "Descrição Geral",
            `<p>Este exercício aborda a implementação dos métodos <strong><code>contem(K,L)</code></strong>, <strong><code>inserir(K,L)</code></strong> e <strong><code>remover(K,L)</code></strong> para diferentes estruturas de dados em C++. Para <strong>filas</strong> e <strong>pilhas</strong>, o método <code>remover</code> não recebe o argumento <code>K</code>, pois a remoção sempre ocorre na extremidade.</p>`
        )}

            ${createContentCard(
            "a) Lista Duplamente Encadeada (Inserção no Final)",
            `
                <h4 class="text-lg font-semibold text-white mb-2">Estrutura de um Nó:</h4>
                ${createCodeBlock(`
struct No {
    T valor;
    No* anterior;
    No* proximo;
};`)}
                <h4 class="text-lg font-semibold text-white mt-4 mb-2">Métodos Essenciais:</h4>
                ${createCodeBlock(`
bool contem_ListaDupla(No<T>* head, T K) {
    No<T>* atual = head;
    while (atual != nullptr) {
        if (atual->valor == K) return true;
        atual = atual->proximo;
    }
    return false;
}


void inserir_ListaDupla(No<T>** head, No<T>** tail, T K) {
    No<T>* novoNo = new No<T>{K, nullptr, nullptr};
    if (*head == nullptr) {
        *head = novoNo;
        *tail = novoNo;
    } else {
        (*tail)->proximo = novoNo;
        novoNo->anterior = *tail;
        *tail = novoNo;
    }
}


bool remover_ListaDupla(No<T>** head, No<T>** tail, T K) {
    if (*head == nullptr) return false;
    No<T>* atual = *head;
    if (atual->valor == K) {
        *head = atual->proximo;
        if (*head != nullptr) (*head)->anterior = nullptr;
        else *tail = nullptr;
        delete atual;
        return true;
    }
    while (atual != nullptr && atual->valor != K) {
        atual = atual->proximo;
    }
    if (atual == nullptr) return false;
    if (atual->proximo != nullptr) atual->proximo->anterior = atual->anterior;
    else *tail = atual->anterior;
    atual->anterior->proximo = atual->proximo;
    delete atual;
    return true;
}`)}
                <p class="mt-4 text-gray-400">
                    <strong>Complexidade:</strong>
                    <ul>
                    <li><code>contem_ListaDupla</code>: <strong>O(n)</strong> (percorre a lista no pior caso).</li>
                    <li><code>inserir_ListaDupla</code>: <strong>O(1)</strong> (inserção no final com acesso direto ao tail).</li>
                    <li><code>remover_ListaDupla</code>: <strong>O(n)</strong> (percorre a lista para encontrar K no pior caso).</li>
                    </ul>
                </p>
                `
        )}

            ${createContentCard(
            "b) Fila com Lista Simplesmente Encadeada",
            `
                <h4 class="text-lg font-semibold text-white mb-2">Estrutura de um Nó:</h4>
                ${createCodeBlock(`
struct NoSimples {
    T valor;
    NoSimples* proximo;
};`)}
                <h4 class="text-lg font-semibold text-white mt-4 mb-2">Métodos Essenciais:</h4>
                ${createCodeBlock(`
bool contem_Fila(NoSimples<T>* head, T K) {
    NoSimples<T>* atual = head;
    while (atual != nullptr) {
        if (atual->valor == K) return true;
        atual = atual->proximo;
    }
    return false;
}


void inserir_Fila(NoSimples<T>** head, NoSimples<T>** tail, T K) {
    NoSimples<T>* novoNo = new NoSimples<T>{K, nullptr};
    if (*head == nullptr) {
        *head = novoNo;
        *tail = novoNo;
    } else {
        (*tail)->proximo = novoNo;
        *tail = novoNo;
    }
}


T remover_Fila(NoSimples<T>** head, NoSimples<T>** tail) {
    if (*head == nullptr) {
        throw std::runtime_error("Fila vazia");
    }
    T valorRemovido = (*head)->valor;
    NoSimples<T>* temp = *head;
    *head = (*head)->proximo;
    if (*head == nullptr) *tail = nullptr;
    delete temp;
    return valorRemovido;
}`)}
                <p class="mt-4 text-gray-400">
                    <strong>Complexidade:</strong>
                    <ul>
                    <li><code>contem_Fila</code>: <strong>O(n)</strong>.</li>
                    <li><code>inserir_Fila</code>: <strong>O(1)</strong>.</li>
                    <li><code>remover_Fila</code>: <strong>O(1)</strong>.</li>
                    </ul>
                </p>
                `
        )}

            ${createContentCard(
            "c) Pilha com Lista Simplesmente Encadeada",
            `
                <h4 class="text-lg font-semibold text-white mb-2">Estrutura de um Nó:</h4>
                <p class="mb-2 text-gray-400"> (Mesma estrutura de <code>NoSimples</code> do item b) </p>
                ${createCodeBlock(`
struct NoSimples {
    T valor;
    NoSimples* proximo;
};`)}
                <h4 class="text-lg font-semibold text-white mt-4 mb-2">Métodos Essenciais:</h4>
                ${createCodeBlock(`
bool contem_Pilha(NoSimples<T>* top, T K) {
    NoSimples<T>* atual = top;
    while (atual != nullptr) {
        if (atual->valor == K) return true;
        atual = atual->proximo;
    }
    return false;
}


void inserir_Pilha(NoSimples<T>** top, T K) {
    NoSimples<T>* novoNo = new NoSimples<T>{K, *top};
    *top = novoNo;
}


T remover_Pilha(NoSimples<T>** top) {
    if (*top == nullptr) {
        throw std::runtime_error("Pilha vazia");
    }
    T valorRemovido = (*top)->valor;
    NoSimples<T>* temp = *top;
    *top = (*top)->proximo;
    delete temp;
    return valorRemovido;
}`)}
                <p class="mt-4 text-gray-400">
                    <strong>Complexidade:</strong>
                    <ul>
                    <li><code>contem_Pilha</code>: <strong>O(n)</strong>.</li>
                    <li><code>inserir_Pilha</code>: <strong>O(1)</strong>.</li>
                    <li><code>remover_Pilha</code>: <strong>O(1)</strong>.</li>
                    </ul>
                </p>
                `
        )}

            ${createContentCard(
            "d) Lista Duplamente Encadeada Circular",
            `
                <h4 class="text-lg font-semibold text-white mb-2">Estrutura de um Nó:</h4>
                <p class="mb-2 text-gray-400"> (Mesma estrutura de <code>No</code> do item a) </p>
                ${createCodeBlock(`struct No {
    T valor;
    No* anterior;
    No* proximo;
};`)}
                <h4 class="text-lg font-semibold text-white mt-4 mb-2">Métodos Essenciais:</h4>
                ${createCodeBlock(`
bool contem_ListaDuplaCircular(No<T>* head, T K) {
    if (head == nullptr) return false;
    No<T>* atual = head;
    do {
        if (atual->valor == K) return true;
        atual = atual->proximo;
    } while (atual != head);
    return false;
}


void inserir_ListaDuplaCircular(No<T>** head, int* tamanho, T K) {
    No<T>* novoNo = new No<T>{K, nullptr, nullptr};
    if (*head == nullptr) {
        *head = novoNo;
        novoNo->proximo = novoNo;
        novoNo->anterior = novoNo;
    } else {
        No<T>* tail = (*head)->anterior;
        novoNo->proximo = *head;
        novoNo->anterior = tail;
        (*head)->anterior = novoNo;
        tail->proximo = novoNo;
    }
    (*tamanho)++;
}


bool remover_ListaDuplaCircular(No<T>** head, int* tamanho, T K) {
    if (*head == nullptr) return false;
    No<T>* atual = *head;
    No<T>* noRemover = nullptr;
    do {
        if (atual->valor == K) {
            noRemover = atual;
            break;
        }
        atual = atual->proximo;
    } while (atual != *head);

    if (noRemover == nullptr) return false;

    if (*tamanho == 1) {
        delete *head;
        *head = nullptr;
    } else {
        noRemover->anterior->proximo = noRemover->proximo;
        noRemover->proximo->anterior = noRemover->anterior;
        if (noRemover == *head) *head = noRemover->proximo;
        delete noRemover;
    }
    (*tamanho)--;
    return true;
}`)}
                <p class="mt-4 text-gray-400">
                    <strong>Complexidade:</strong>
                    <ul>
                    <li><code>contem_ListaDuplaCircular</code>: <strong>O(n)</strong>.</li>
                    <li><code>inserir_ListaDuplaCircular</code>: <strong>O(1)</strong>.</li>
                    <li><code>remover_ListaDuplaCircular</code>: <strong>O(n)</strong>.</li>
                    </ul>
                </p>
                `
        )}
        `;

        // Conteúdo para o Exercício 2
        const exercise2Content = `
            <h2 class="text-3xl sm:text-4xl font-bold text-white mb-6">Exercício 2: Soma de Inteiros Grandes com Listas Encadeadas</h2>
            ${createContentCard(
            "Descrição Geral",
            `<p>Este algoritmo soma dois <strong>inteiros grandes</strong> representados por listas encadeadas, onde cada dígito do inteiro é armazenado em um nó da lista. O resultado é uma nova lista <code>L3 = L1 + L2</code>.</p>
                <p class="mt-2">A estratégia principal é <strong>inverter</strong> as listas de entrada para somar os dígitos da direita para a esquerda (unidades para milhares), simulando a adição manual.</p>`
        )}

            ${createContentCard(
            "Estruturas e Funções Auxiliares",
            `
                <h4 class="text-lg font-semibold text-white mb-2">Estrutura de um Nó para Dígito:</h4>
                ${createCodeBlock(`struct NoDigito {
    int digito;
    NoDigito* proximo;
};`)}
                <h4 class="text-lg font-semibold text-white mt-4 mb-2">Função Auxiliar para Inverter uma Lista:</h4>
                ${createCodeBlock(`NoDigito* inverterLista(NoDigito* head) {
    NoDigito* anterior = nullptr;
    NoDigito* atual = head;
    NoDigito* proximo = nullptr;
    while (atual != nullptr) {
        proximo = atual->proximo;
        atual->proximo = anterior;
        anterior = atual;
        atual = proximo;
    }
    return anterior;
}`)}
                `
        )}

            ${createContentCard(
            "Algoritmo Principal: somaInteirosGrandes",
            `
                ${createCodeBlock(`NoDigito* somaInteirosGrandes(NoDigito* L1_head, NoDigito* L2_head) {
    NoDigito* L1_invertida = inverterLista(L1_head);
    NoDigito* L2_invertida = inverterLista(L2_head);

    NoDigito* L3_head = nullptr;
    NoDigito* L3_tail = nullptr;
    int carry = 0;

    NoDigito* atual1 = L1_invertida;
    NoDigito* atual2 = L2_invertida;

    while (atual1 != nullptr || atual2 != nullptr || carry > 0) {
        int digito1 = atual1 ? atual1->digito : 0;
        int digito2 = atual2 ? atual2->digito : 0;

        int soma = digito1 + digito2 + carry;
        int novoDigito = soma % 10;
        carry = soma / 10;

        NoDigito* novoNo = new NoDigito{novoDigito, nullptr};
        if (L3_head == nullptr) {
            L3_head = novoNo;
            L3_tail = novoNo;
        } else {
            L3_tail->proximo = novoNo;
            L3_tail = novoNo;
        }

        if (atual1) atual1 = atual1->proximo;
        if (atual2) atual2 = atual2->proximo;
    }
    return inverterLista(L3_head);
}`)}
                <p class="mt-4 text-gray-400">
                    <strong>Complexidade:</strong> A complexidade da função <code>somaInteirosGrandes</code> é <strong>O(max(n, m))</strong>, onde <code>n</code> é o número de dígitos em <code>L1</code> e <code>m</code> é o número de dígitos em <code>L2</code>. Isso se deve às operações de inversão de lista (O(n) e O(m)) e ao laço de soma, que percorre as listas uma vez.
                </p>
                `
        )}
        `;

        // Conteúdo para o Exercício 3
        const exercise3Content = `
            <h2 class="text-3xl sm:text-4xl font-bold text-white mb-6">Exercício 3: Manipulação de Lista Simplesmente Encadeada</h2>
            ${createContentCard(
            "Descrição Geral",
            `<p>Este exercício pede para manipular uma lista simplesmente encadeada <code>L</code>, criando duas novas listas a partir dela, percorrendo a lista original <strong>apenas uma vez</strong> para cada criação.</p>`
        )}

            ${createContentCard(
            "a) Criação de L' (Ordem Inversa)",
            `
                <p class="mb-4 text-gray-400">Crie uma lista <code>L'</code> que contenha os valores de <code>L</code> em ordem inversa. A ideia é inserir cada elemento da lista original no <strong>início</strong> da nova lista, revertendo a ordem.</p>
                <h4 class="text-lg font-semibold text-white mb-2">Estrutura de um Nó:</h4>
                ${createCodeBlock(`
struct NoSimples {
    T valor;
    NoSimples* proximo;
};`)}
                <h4 class="text-lg font-semibold text-white mt-4 mb-2">Algoritmo: inverterListaEmLPrime</h4>
                ${createCodeBlock(`
NoSimples<T>* inverterListaEmLPrime(NoSimples<T>* L_head) {
    NoSimples<T>* LPrime_head = nullptr; // Head da nova lista L'

    NoSimples<T>* atual = L_head;
    while (atual != nullptr) {
        NoSimples<T>* novoNo = new NoSimples<T>{atual->valor, LPrime_head};
        LPrime_head = novoNo; // O novo nó se torna o novo head de L'
        atual = atual->proximo;
    }
    return LPrime_head;
}`)}
                <p class="mt-4 text-gray-400">
                    <strong>Complexidade:</strong> A complexidade é <strong>O(n)</strong>, onde <code>n</code> é o número de nós em <code>L</code>, pois a lista é percorrida uma única vez.
                </p>
                `
        )}

            ${createContentCard(
            "b) Criação de L'' (Soma de Pares de Nós)",
            `
                <p class="mb-4 text-gray-400">Crie uma lista <code>L''</code> com metade dos nós de <code>L</code>. Cada nó de <code>L''</code> é a soma de um nó do início de <code>L</code> com um nó do final de <code>L</code> (ex: $L1+Ln, L2+Ln-1, ...$). Assume-se que <code>n</code> (tamanho de <code>L</code>) é <strong>par</strong>.</p>
                <p class="mb-4 text-gray-400">A estratégia é usar uma <strong>pilha</strong> para armazenar a segunda metade da lista, permitindo acesso inverso aos elementos enquanto se percorre a primeira metade.</p>
                <h4 class="text-lg font-semibold text-white mb-2">Estrutura de um Nó:</h4>
                <p class="mb-2 text-gray-400"> (Mesma estrutura de <code>NoSimples</code> do item a) </p>
                ${createCodeBlock(`
struct NoSimples {
    T valor;
    NoSimples* proximo;
};`)}
                <h4 class="text-lg font-semibold text-white mt-4 mb-2">Algoritmo: somaParesDeNos</h4>
                ${createCodeBlock(`// Incluir <vector> para std::vector (usado como pilha)

NoSimples<T>* somaParesDeNos(NoSimples<T>* L_head) {
    if (L_head == nullptr) return nullptr;

    NoSimples<T>* LDoublePrime_head = nullptr;
    NoSimples<T>* LDoublePrime_tail = nullptr;

    std::vector<T> pilha;
    NoSimples<T>* lento = L_head;
    NoSimples<T>* rapido = L_head;

    // Encontra o meio da lista (lento estará no início da segunda metade para N par)
    while (rapido != nullptr && rapido->proximo != nullptr) {
        rapido = rapido->proximo->proximo;
        lento = lento->proximo;
    }

    // Empilha os elementos da segunda metade
    NoSimples<T>* segundaMetade = lento;
    while (segundaMetade != nullptr) {
        pilha.push_back(segundaMetade->valor);
        segundaMetade = segundaMetade->proximo;
    }

    // Soma a primeira metade com os elementos desempilhados
    NoSimples<T>* atual = L_head;
    while (!pilha.empty()) {
        T valorL2 = pilha.back(); pilha.pop_back();
        T soma = atual->valor + valorL2;

        NoSimples<T>* novoNo = new NoSimples<T>{soma, nullptr};
        if (LDoublePrime_head == nullptr) {
            LDoublePrime_head = novoNo;
            LDoublePrime_tail = novoNo;
        } else {
            LDoublePrime_tail->proximo = novoNo;
            LDoublePrime_tail = novoNo;
        }
        atual = atual->proximo;
    }
    return LDoublePrime_head;
}`)}
                <p class="mt-4 text-gray-400">
                    <strong>Complexidade:</strong> A complexidade é <strong>O(n)</strong>. A lista é percorrida para encontrar o meio e empilhar (O(n)), e depois a primeira metade é percorrida e somada com os elementos desempilhados (O(n/2)).
                </p>
                `
        )}
        `;

        // Conteúdo para o Exercício 4
        const exercise4Content = `
            <h2 class="text-3xl sm:text-4xl font-bold text-white mb-6">Exercício 4: Reconhecimento de Palíndromo com Lista Encadeada</h2>
            ${createContentCard(
            "Descrição Geral",
            `<p>Este algoritmo verifica se uma palavra, armazenada em uma lista simplesmente encadeada (onde cada nó contém um caractere), é um <strong>palíndromo</strong>. Um palíndromo é uma sequência que se lê da mesma forma de trás para frente e de frente para trás (ex: "ARARA", "MADAM").</p>
                <p class="mt-2">A solução utiliza uma <strong>pilha</strong> para armazenar a primeira metade dos caracteres, permitindo a comparação eficiente com a segunda metade da lista na ordem inversa.</p>`
        )}

            ${createContentCard(
            "Estrutura e Algoritmo",
            `
                <h4 class="text-lg font-semibold text-white mb-2">Estrutura de um Nó para Caractere:</h4>
                ${createCodeBlock(`struct NoCaractere {
    char caractere;
    NoCaractere* proximo;
};`)}
                <h4 class="text-lg font-semibold text-white mt-4 mb-2">Algoritmo: ehPalindromo</h4>
                ${createCodeBlock(`// Incluir <stack> para std::stack

bool ehPalindromo(NoCaractere* L_head) {
    if (L_head == nullptr || L_head->proximo == nullptr) {
        return true; // Lista vazia ou com um único caractere é um palíndromo
    }

    std::stack<char> pilha;
    NoCaractere* lento = L_head;
    NoCaractere* rapido = L_head;

    // Percorre a lista com ponteiros lento e rápido para encontrar o meio
    // e empilha a primeira metade dos caracteres.
    while (rapido != nullptr && rapido->proximo != nullptr) {
        pilha.push(lento->caractere);
        lento = lento->proximo;
        rapido = rapido->proximo->proximo;
    }

    // Se a lista tiver um número ímpar de elementos, o ponteiro lento
    // estará no caractere do meio. Avançamos ele para iniciar a comparação
    // da segunda metade.
    if (rapido != nullptr) {
        lento = lento->proximo;
    }

    // Compara a segunda metade da lista com os caracteres desempilhados.
    // Os elementos da pilha estão na ordem inversa da primeira metade.
    while (lento != nullptr) {
        if (pilha.top() != lento->caractere) return false; // Se diferentes, não é palíndromo
        pilha.pop();
        lento = lento->proximo;
    }
    return true; // É um palíndromo
}`)}
                <p class="mt-4 text-gray-400">
                    <strong>Complexidade:</strong> A complexidade é <strong>O(n)</strong>, onde <code>n</code> é o número de caracteres na lista. A lista é percorrida uma vez para encher a pilha (até a metade) e uma vez para comparar com a segunda metade.
                </p>
                `
        )}
        `;

        // Conteúdo para o Exercício 5
        const exercise5Content = `
            <h2 class="text-3xl sm:text-4xl font-bold text-white mb-6">Exercício 5: Matriz Esparsa (Representação e Operações)</h2>
            ${createContentCard(
            "Descrição Geral",
            `<p>Este exercício trata de uma <strong>matriz esparsa</strong> (matriz com muitos zeros). O objetivo é representá-la de forma eficiente em termos de espaço (<code>O(k)</code>, onde <code>k</code> é o número de elementos não irrelevantes) e implementar operações como localização e multiplicação ($A^2$).</p>
                <p class="mt-2">A representação utiliza uma estrutura de <strong>listas encadeadas cruzadas</strong>, com vetores de cabeçalhos para linhas e colunas, que apontam para os elementos não nulos.</p>`
        )}

            ${createContentCard(
            "a) Estrutura de Dados para Matriz Esparsa",
            `
                <h4 class="text-lg font-semibold text-white mb-2">Estrutura do Nó de Elemento:</h4>
                ${createCodeBlock(`
struct NoElemento {
    T valor;
    int linha;
    int coluna;
    NoElemento* proximoLinha; // Próximo elemento na mesma linha
    NoElemento* proximoColuna; // Próximo elemento na mesma coluna
};`)}
                <h4 class="text-lg font-semibold text-white mt-4 mb-2">Métodos Essenciais (para \`std::vector<NoElemento<T>*>& linhasHead\` e \`colunasHead\`):</h4>
                ${createCodeBlock(`// Incluir <vector> para std::vector


void inserir_MatrizEsparsa(
    int numLinhas, int numColunas,
    std::vector<NoElemento<T>*>& linhasHead,
    std::vector<NoElemento<T>*>& colunasHead,
    T valor, int linha, int coluna) {

    if (linha < 0 || linha >= numLinhas || coluna < 0 || coluna >= numColunas || valor == 0) return;

    NoElemento<T>* novoNo = new NoElemento<T>{valor, linha, coluna, nullptr, nullptr};

    novoNo->proximoLinha = linhasHead[linha];
    linhasHead[linha] = novoNo;

    novoNo->proximoColuna = colunasHead[coluna];
    colunasHead[coluna] = novoNo;
}`)}
                <p class="mt-4 text-gray-400">
                    <strong>Complexidade de Espaço:</strong> <strong>O(k)</strong>, onde <code>k</code> é o número total de elementos não nulos.
                </p>
                `
        )}

            ${createContentCard(
            "b) Algoritmo para Localizar um Valor aij",
            `
                <p class="mb-4 text-gray-400">O algoritmo para localizar um valor $a_{ij}$ na matriz esparsa é implementado pela função <code>buscar_MatrizEsparsa</code>.</p>
                <h4 class="text-lg font-semibold text-white mb-2">Algoritmo: buscar_MatrizEsparsa</h4>
                ${createCodeBlock(`
NoElemento<T>* buscar_MatrizEsparsa(
    int numLinhas, int numColunas,
    std::vector<NoElemento<T>*>& linhasHead,
    std::vector<NoElemento<T>*>& colunasHead,
    int linha, int coluna) {

    if (linha < 0 || linha >= numLinhas || coluna < 0 || coluna >= numColunas) return nullptr;

    NoElemento<T>* atual = linhasHead[linha];
    while (atual != nullptr) {
        if (atual->coluna == coluna) return atual;
        atual = atual->proximoLinha;
    }
    return nullptr;
}`)}
                <p class="mt-4 text-gray-400">
                    <strong>Complexidade:</strong> <strong>O(número de elementos não nulos na linha <code>i</code>)</strong> no pior caso, o que pode ser <strong>O(k)</strong> se a linha estiver cheia.
                </p>
                `
        )}

            ${createContentCard(
            "c) Algoritmo para Computar A²",
            `
                <p class="mb-4 text-gray-400">Este algoritmo calcula o produto da matriz <code>A</code> por ela mesma ($A \times A = A^2$), onde <code>A</code> deve ser uma matriz quadrada. Ele utiliza os métodos de inserção e busca da própria estrutura de matriz esparsa.</p>
                <h4 class="text-lg font-semibold text-white mb-2">Algoritmo: computarAQuadrado</h4>
                ${createCodeBlock(`// Incluir <stdexcept> para std::runtime_error


std::vector<NoElemento<T>*> computarAQuadrado(
    int numLinhas, int numColunas,
    std::vector<NoElemento<T>*>& linhasHeadA,
    std::vector<NoElemento<T>*>& colunasHeadA) {

    if (numLinhas != numColunas) {
        throw std::runtime_error("A matriz não é quadrada para calcular A^2.");
    }

    // Criar uma nova estrutura para o resultado A^2
    std::vector<NoElemento<T>*> linhasHeadResultado(numLinhas, nullptr);
    std::vector<NoElemento<T>*> colunasHeadResultado(numColunas, nullptr);

    for (int i = 0; i < numLinhas; ++i) {
        for (int j = 0; j < numColunas; ++j) {
            T somaProduto = 0;

            // Percorre elementos não nulos da linha 'i' de A
            NoElemento<T>* elementoA_linha_i = linhasHeadA[i];
            while (elementoA_linha_i != nullptr) {
                T A_ik = elementoA_linha_i->valor;
                int k = elementoA_linha_i->coluna;

                // Busca o elemento A[k][j] na coluna 'j' de A
                NoElemento<T>* elementoA_coluna_j = colunasHeadA[j];
                while (elementoA_coluna_j != nullptr) {
                    if (elementoA_coluna_j->linha == k) {
                        T A_kj = elementoA_coluna_j->valor;
                        somaProduto += A_ik * A_kj;
                        break;
                    }
                    elementoA_coluna_j = elementoA_coluna_j->proximoColuna;
                }
                elementoA_linha_i = elementoA_linha_i->proximoLinha;
            }

            if (somaProduto != 0) {
                // Inserir no resultado usando a função auxiliar de inserção
                // (Para a implementação completa, as heads do resultado seriam passadas aqui)
                // inserir_MatrizEsparsa(numLinhas, numColunas, linhasHeadResultado, colunasHeadResultado, somaProduto, i, j);
            }
        }
    }
    return linhasHeadResultado; // Retorna o head das linhas da matriz resultado
}`)}
                <p class="mt-4 text-gray-400">
                    <strong>d) Complexidade da Solução para a Letra (c):</strong>
                    <p class="mt-2 text-gray-400">A complexidade desta implementação é <strong>O(N^4)</strong> no pior caso, onde <code>N</code> é a dimensão da matriz quadrada. Isso ocorre porque há dois laços aninhados ($i$ e $j$), e dentro deles, duas iterações sobre as listas encadeadas de linhas e colunas. Em matrizes esparsas, o desempenho real pode ser melhor se as listas de linhas/colunas forem curtas, mas no cenário mais denso (onde as listas têm <code>N</code> elementos), a complexidade atinge <code>N^4</code>.</p>
                </p>
                `
        )}
        `;

        // Mapeia os IDs dos exercícios para seus conteúdos
        const exerciseContents = {
            '1': exercise1Content,
            '2': exercise2Content,
            '3': exercise3Content,
            '4': exercise4Content,
            '5': exercise5Content
        };

        let currentActiveButton = null;

        // Função para mostrar o exercício selecionado
        function showExercise(exerciseId) {
            const contentArea = document.getElementById('content-area');
            contentArea.innerHTML = exerciseContents[exerciseId];

            // Desativa o botão anterior e ativa o novo
            if (currentActiveButton) {
                currentActiveButton.classList.remove('bg-blue-600', 'text-white', 'shadow-md');
                currentActiveButton.classList.add('bg-gray-700', 'text-gray-200', 'hover:bg-blue-500', 'hover:text-white');
            }
            const newActiveButton = document.getElementById(`btn-exercise-${exerciseId}`);
            if (newActiveButton) {
                newActiveButton.classList.remove('bg-gray-700', 'text-gray-200', 'hover:bg-blue-500', 'hover:text-white');
                newActiveButton.classList.add('bg-blue-600', 'text-white', 'shadow-md');
                currentActiveButton = newActiveButton;
            }
        }

        // Carrega o Exercício 1 por padrão ao carregar a página
        document.addEventListener('DOMContentLoaded', () => {
            showExercise('1');
        });
    </script>
</body>

</html>